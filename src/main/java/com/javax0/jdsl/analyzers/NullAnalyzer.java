package com.javax0.jdsl.analyzers;

import com.javax0.jdsl.GrammarDefinition;

/**
 * The {@link NullAnalyzer} does not analyze anything. It ignores the source
 * code it gets as argument to the method {@link #analyze(SourceCode)}. What it
 * does is that it executes the {@link Closure#exec(SourceCode)} method of the
 * object that is passed to the constructor (which is private anyway) when the
 * analyzer is created.
 * <p>
 * The intended use of the analyzer is to statically import the
 * {@link #exec(Closure)} method into the {@link GrammarDefinition} and use that
 * to have some code to be executed at certain point. That certain point is
 * usually in a list or alternative analyzers in the argument list of a call to
 * the methods like {@link GrammarDefinition#list(Analyzer...)} or
 * {@link GrammarDefinition#oneOf(Analyzer...)}.
 * <p>
 * The {@link NullAnalyzer} returns successful result and the state it returns
 * is the one returned by the closure. Even though the return value is a
 * successful result it can be used as argument to
 * {@link GrammarDefinition#oneOf(Analyzer...)} or
 * {@link GrammarDefinition#or(Analyzer...)}, because the
 * {@link AlternativesAnalyzer} these methods call recognizes that the result
 * was coming from a {@link NullAnalyzer} and ignores the result. IN this case
 * any state generated by the execution is also lost.
 * <p>
 * 
 * @author Peter Verhas
 * 
 */
public class NullAnalyzer implements Rule {

	private final Closure closure;

	private NullAnalyzer(Closure closure) {
		this.closure = closure;
	}

	public static Rule exec(Closure closure) {
		return new NullAnalyzer(closure);
	}

	@Override
	public AnalysisResult analyze(SourceCode input) {
		return SimpleAnalysisResult.success(NullAnalyzer.class, input, null,
				closure.exec(input));
	}

}
