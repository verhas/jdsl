package com.javax0.jdsl.analyzers;

import com.javax0.jdsl.GrammarDefinition;

/**
 * The {@link NullAnalyzer} does not analyze anything. It ignores the source
 * code it gets as argument to the method {@link #analyze(SourceCode)}. What it
 * does is that it executes the {@link Closure#exec(SourceCode)} method of the
 * object that is passed to the constructor. (Note that the constructor is
 * private, because you are supposed to call the static method {@link #exec(Closure)}).
 * <p>
 * The intended use of the analyzer is to statically import the
 * {@link #exec(Closure)} method into the {@link GrammarDefinition} and use that
 * to have some code to be executed at certain point. That certain point is
 * usually in a list or alternative analyzers in the argument list of a call to
 * the methods like {@link GrammarDefinition#list(Analyzer...)} or
 * {@link GrammarDefinition#oneOf(Analyzer...)}.
 * <p>
 * The {@link NullAnalyzer} returns successful result and the state it returns
 * is the one returned by the closure. Even though the return value is a
 * successful result it still can be used as argument to
 * {@link GrammarDefinition#oneOf(Analyzer...)} or
 * {@link GrammarDefinition#or(Analyzer...)}, because in the
 * {@link AlternativesAnalyzer} these methods recognize that the result
 * was coming from a {@link NullAnalyzer} and ignore the result. In this case
 * any state generated by the execution is also lost.
 * <p>
 * 
 *
 * 
 */
public class NullAnalyzer implements Rule {

	private final Closure closure;

	private NullAnalyzer(Closure closure) {
		this.closure = closure;
	}

	public static Rule exec(Closure closure) {
		return new NullAnalyzer(closure);
	}

	@Override
	public AnalysisResult analyze(SourceCode input) {
		return SimpleAnalysisResult.success(NullAnalyzer.class, input, null,
				closure.exec(input));
	}

}
